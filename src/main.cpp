//
//  main.cpp
//  Bits
//
//  Created by Burak on 1.12.2022.
//
#include "header.h"
#include "arith_uint256.h"
#include <chrono>
#include "transaction/transaction.h"
#include "block/block.h"
#include "prover/prover.h"




using namespace std::chrono;

valtype stringToValtype(std::string const& hex) {
    
    std::string newStr = "";
    
    for (int i = 0; i < (hex.size()/2); i++) {
        newStr += hex.substr((i*2),2) + " ";
    }
    
    std::string cipher = newStr;
    
    
    std::istringstream strm{cipher};
    strm >> std::hex;

    return {std::istream_iterator<int>{strm}, {}};
}


uint32_t getCurrentHeaderSyncHeight() {
    return HeaderSync::getSyncHeight();
}

uint32_t submitRawHeader(unsigned char rawHeader[80]){
    Header *newHeader = new Header(WizData::buffer80ToValtype(rawHeader));
    bool success = (newHeader->height > 0);
    if (!success) delete newHeader;
    return HeaderSync::syncHeight;
}

uint32_t submitHeaderFromComponents(uint32_t version, unsigned char prevHash[32], unsigned char merkeRoot[32], uint32_t timestamp, uint32_t bits, uint32_t nonce){
    Header *newHeader = new Header(version, WizData::buffer32ToValtype(prevHash), WizData::buffer32ToValtype(merkeRoot), timestamp, bits, nonce);
    bool success = (newHeader->height > 0);
    if (!success) delete newHeader;
    return HeaderSync::syncHeight;
}

bool initHeaderSyncGenesis() {
    HeaderSync();
    return (HeaderSync::ancestorPast11Timestamps.size() == 11);
}

bool initHeaderSyncFromHeightWithComponents(uint32_t startHeight, uint32_t version, valtype prevHash, valtype merkeRoot, uint32_t timestamp, uint32_t bits, uint32_t nonce, uint32_t periodBits, uint32_t periodTimestamp, int atsAr[11]) {
    HeaderSync(startHeight, version, prevHash, merkeRoot, timestamp, bits, nonce, periodBits, periodTimestamp, atsAr);
    return (HeaderSync::ancestorPast11Timestamps.size() == 11);
}

bool initHeaderSyncFromHeightRaw(uint32_t startHeight, valtype rawHeader, uint32_t periodBits, uint32_t periodTimestamp, int atsAr[11]) {
    HeaderSync(startHeight, rawHeader, periodBits, periodTimestamp, atsAr);
    return (HeaderSync::ancestorPast11Timestamps.size() == 11);
}

void test_submit_header_1() {
    
    valtype rawHeader = stringToValtype("010000006fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000982051fd1e4ba744bbbe680e1fee14677ba1a3c3540bf7b1cdb606e857233e0e61bc6649ffff001d01e36299");

    Header *newHeader = new Header(rawHeader);
    bool success = (newHeader->height > 0);
    if (!success) delete newHeader;
    
    std::cout << "submit: " << success << std::endl;
    
}

void test_submit_header_2() {
    valtype x1 = WizData::hexStringToValtype("4860eb18bf1b1620e37e9490fc8a427514");
    valtype x2 = WizData::hexStringToValtype("416fd75159ab86688e9a8300000000");
    valtype x3 = WizData::hexStringToValtype("d5fdcc541e25de1c7a5addedf24858b8");
    valtype x4 = WizData::hexStringToValtype("bb665c9f36ef744ee42c316022c90f9b");
    
    valtype prevHash;
    prevHash.insert(prevHash.begin(), x1.begin(),x1.end());
    prevHash.insert(prevHash.begin() + x1.size() , x2.begin(),x2.end());
    valtype merkeRoot;
    merkeRoot.insert(merkeRoot.begin(), x3.begin(),x3.end());
    merkeRoot.insert(merkeRoot.begin() + x3.size() , x4.begin(),x4.end());
    
    Header *newHeader = new Header(1, prevHash, merkeRoot, 1231469744, 486604799, 1639830024);
    bool success = (newHeader->height > 0);
    if (!success) delete newHeader;
    
    std::cout << "submit: " << success << std::endl;
    }

void test_submit_header_3() {
    valtype x1 = WizData::hexStringToValtype("bddd99ccfda39da1b108ce1a5d7003");
    valtype x2 = WizData::hexStringToValtype("8d0a967bacb68b6b63065f626a00000000");
    valtype x3 = WizData::hexStringToValtype("44f672226090d85db9a9f2fbfe5f0f96");
    valtype x4 = WizData::hexStringToValtype("09b387af7be5b7fbb7a1767c831c9e99");
    
    valtype prevHash;
    prevHash.insert(prevHash.begin(), x1.begin(),x1.end());
    prevHash.insert(prevHash.begin() + x1.size() , x2.begin(),x2.end());
    valtype merkeRoot;
    merkeRoot.insert(merkeRoot.begin(), x3.begin(),x3.end());
    merkeRoot.insert(merkeRoot.begin() + x3.size() , x4.begin(),x4.end());
    
    Header *newHeader = new Header(1, prevHash, merkeRoot, 1231470173, 486604799, 1844305925);
    bool success = (newHeader->height > 0);
    if (!success) delete newHeader;
    
    std::cout << "submit: " << success << std::endl;
    }




int main() {
    
    //valtype x1 = WizData::hexStringToValtype("4860eb18bf1b1620e37e9490fc8a427514");
    //valtype x2 = WizData::hexStringToValtype("416fd75159ab86688e9a8300000000");
    //valtype x3 = WizData::hexStringToValtype("d5fdcc541e25de1c7a5addedf24858b8");
    //valtype x4 = WizData::hexStringToValtype("bb665c9f36ef744ee42c316022c90f9b");
    
    //valtype prevHash;
    //prevHash.insert(prevHash.begin(), x1.begin(),x1.end());
    //prevHash.insert(prevHash.begin() + x1.size() , x2.begin(),x2.end());
    // valtype merkeRoot;
    //merkeRoot.insert(merkeRoot.begin(), x3.begin(),x3.end());
    //merkeRoot.insert(merkeRoot.begin() + x3.size() , x4.begin(),x4.end());
    
    //int tsar[] = {0,0,0,0,0,0,0,0,0,0,0};
    
    //initHeaderSyncFromHeightWithComponents(2, 1, prevHash, merkeRoot, 1231469744, 486604799, 1639830024, 486604799, 1231006505, tsar);
   
    //initHeaderSyncGenesis();
    //test_submit_header_1();
    
    //test_submit_header_2();
    //test_submit_header_3();
    
    valtype rawblock = stringToValtype("010000006FD2C5A8FAC33DBE89BB2A2947A73EED2AFC3B1D4F886942DF08000000000000B152ECA4364850F3424C7AC2B337D606C5CA0A3F96F1554F8DB33D2F6F130BBED325A04E4B6D0B1A85790E6B0A01000000010000000000000000000000000000000000000000000000000000000000000000FFFFFFFF08044B6D0B1A020B02FFFFFFFF0100F2052A01000000434104E8E37F1556B53B557405FC7924C861E640C8F99EBB3FEB09AE69A84BEA1F125940309BEEC02FB815EA5E68782C32DA123B4585BC2F23731F1F1C62C9727DBA9DAC0000000001000000015CB590074343C7665750694DF9DACAEC463763C92FE7EBCBC59D434BEEA01DFF000000008B483045022100F570245FDFC5F5ADF435F9888D97DE7C6173AACE9785F3B3601B859AB9522582022030434C7883546A5F8573910D8A6BF9E0254A7C767F24F41EB50D5559E74D6D33014104F35021FA17CDFFC2CE05526A0305A55D34E92DD88D8A63A5A55963E3884166CCA2BC894FBAF56D0FA6F673BE9D6605962D56AD034F507FFE6F5671C91CEC7617FFFFFFFF020077505B000000001976A9140463643DDC0A1044C26C86E6AF5436515814939D88ACC0DAE795000000001976A914AD46C3EA24A7429513FA25582134F2BEC3A296BB88AC00000000010000000792385B38AF452E52EB7259F95A100C77EC06B80556FA6ECA0102C84768770A10000000008B483045022100B61B8132060E810387518DBD697F731EB1680DEBF3882ED04821A5D54CED2BCA022017A5356096F7DB93D9B989114E248476D37325AAB7EBC2A8F5800A2E9E6A66180141047BADE8836F9CCD1923851351E70683606D86A22B6C78676EA3EAE343AFF5C8C3964E39C9EDCF11807949BD325C9475B14DE3DCD91B354A7E9D64A0E9B3E10F6BFFFFFFFF5C6EA87DBCA8237126B7762991672F2B37892A6D487F3E3ECEEC056B94734A02010000008C493046022100872162C6C479FB00D08184EC581958E384DA86BC6696B356BB4F0CF8F34889E6022100E26EF459C676CFF6C012505D53DA4A2A5B62409DF40FDBB8DA3E541B5076774F014104AC50BFD0087FB5558FDF533B743BFCC0671DA8394D2A9A7B3E1927D63FE8D149D24F91F276D61BD5E341AA7ADE7CA4D15E8669B9BFD058F42A9BE0E3B87D5000FFFFFFFFECA12D29FB91447726128E2F6AA5C5567F4619668D8AD725E17AB1CFEA9CA778010000008A473044022071189AF8B6BFB5913310C8CDF24F3544808FADD65E107F3BB2257583AD7B78CD022038DB1B9FC1B5412733FDC7420FF543A306920D206CD9B6360005203BFDEECBFB0141046DB43A2A416854E660917BE0DBBDFF2E9929F69B82DED4C007A3A936DAC18CF93FEA1207AFC20E700E8D496E495C966200080E01ACE36D33E7E4AC8510F32C6DFFFFFFFFC1CCCBC5FBD98AD0C152FCA91C46A023A8F70F38ABEC7301945D7B00A4F20297170000008B48304502205B364BBFD3639936EDA981AC042F0AD07F7F177030648A5CF47EEE974C3F9B4F022100D00AE6DB95D8246C262D1B3EC6AD1A422CA285A4414CE88E6E1B0142B5D8121A014104FA2837995FE7BF88F447B3974416233AB6C048CAA31EEEF5AEE2AEC0CD43C3E0580AFB597763E06D85FA55F291AA97A83B89912F643535ED633D206EE51F95D0FFFFFFFFCC384A8E17AC35522390273B2673480B11FE8BF31E12A11B0B1CF477B66062A7010000008C493046022100A8D8E5EDF0F0DA85E7270E8BC6C388B0388D654DB0ABC36A92907BC9E957E60C022100B811CCA7C8AC220B8DF7EE196DA5C1CD08069CCF1503E63A0151A592498F6DBE0141043DE63A89F4DFCF1CFC0B116BCA2B3F31C87F7ECAB6B8492D735C956A623F7B2C3FFE4971283EC9B3F09842D7CC18D86B3010AFD52451540A3E51854D9178B36DFFFFFFFF353C30D28EE407FED02A34C291015AF047FC0BFED209B32E1143CEC0B521676F000000008B483045022100D231C4C69E6B9D07F219E25633D24917AA08062DCE26FB35C74EC157702961E00220686A31417389DBB053829FE5F5AA3752B732875BBCA37617651BCB2AFF34296D01410460F007004784AE34D4CBF33699962CC030B7202F4395ACF1E19140944C1640DCBE2CE9D114B49286F3F4AFE2A1BFBC4E0FD7B38142ECA3C6F5BFF78C85557432FFFFFFFF1085BF47E0A09DB6943D9D3A17DE75E890D764408341323124A3AC722FEED5A4000000008C493046022100F11950ABE02EF35BAD3498B1AFA79004726989521B78F2123F6C761DF5C38202022100CEE5A42AEEB6C136B294C8A47490308BFF0D1A5C66861566DD150656751DD0B101410490FD02EF1F831BF3BDD8FC080267DC4617E9C3BB3DE7D60EB8A9D33FC639815F873A375AD1D776EB9715A0DC0AE10956B73877E860C595F6C20F74B75CF9FCB0FFFFFFFF0200520F00000000001976A914B9C1C239768C0A4584CA82B466E2DC224D0F51A288AC00EA2EB3060000001976A914120B1F16D9E6EF9CE35BDB011F6B08C338ACF7FC88AC000000000100000001393DE7C30F2AF0383F3BA071C323A2F71C2F8E4B1056AA54B426DCBB0DFD36B0000000008B4830450221009C0019582E97AD740C8EAD4B807B3E305D676E6319A8814258F01BA5E6FDF1B402207DC76C6A6A4D70C4DAA824F7DB6FDBAF23AC76519476D10C093371656DF741C5014104F539BB14BAC4DAE65B5D1405DB3CE4066DBFA2CF3F3601A1FD42D0DB952F94EFA33C48CD27302BF9AD165DAFAFC4EB0C50D2BE29FF200F61C3F229E75F89D348FFFFFFFF0213CB653C040000001976A91456C78DEB3627490BB61EE9C583F3837D84D3D2D688AC242D9E00000000001976A9148F8094807A90A7A175BC51E9885EBEBF92CF51F388AC000000000100000001BBD68D7F493D019529DD273118203C179D8EC9E6F8E51F0A379FD0B730DCC2AC000000008A473044022013BE85140C9F8E3514826AA16E074F9443BA4FC50F719165701CDF7907C056080220787E32A28606231DA3D34F1A5E4E448AF23697A1D4C76E604929A97596145DE3014104704925CC590DF81869DABB78154F75157B55F4977530BD911175ECB4F1D862AF33616FA22EAD59B43FFF5516DB16152DC89651AEA4D5E1DEB8E7EAFECB03033BFFFFFFFF0239273F0B010000001976A9141DA1B8197B1D766053331389BA1BA569EF922D9A88AC80841E00000000001976A91415EE5DA85E59D4BA23E15F9241DCBD14CC126B3C88AC000000000100000001FA6363D222180BE004CD98AE5FEEF3F413EFCFD97D7E15C0620FB7F21E6D6975000000008B483045022100C31FE8E263AE282633D36C761B65FF4A566F09DDF0DA201F903A1E6C159B0AC4022074B80000B02EE8578DB7522C7D7F7D2044DFA105F56E8FC1E9D27C97A033ABD6014104BEEC61E3ACF22E5AA6C97AE354FC65555E26DD444F620D113D7FEBA7A8815AB15205EE8FEC4E13AF1777610A91F6B030B072BE663DB972FE0C394411F0FB2BC1FFFFFFFF0230D9D2F0000000001976A91470BCB5186044C09E532DDC2914B61C0A2B07876188AC00093D00000000001976A9149A58E9696FE10B44BF2C91B2CB18C2DED593041788AC0000000001000000016F1B9F3C986027A869D1AFFD813181786F7DA8A22B70A244021AA99F4542777A000000008B48304502200EFA503A09FA3B74A9A663A94649BFA9268E44B8079F506BE990DB83DE60309E022100DF7EB9FBD1F59DD62AC1ED17F22E9527F5EC402DB04E13070D98CC5491778724014104961C6ACF647B244C91D83F1D2A5DF8421C81A584DEEBDC3A00D1B80113DE6420FFDD00BD2F0984F001B7386BC4F3F80DEAE550F035FF81D6D01B9D907B719A68FFFFFFFF02400DCD02010000001976A914287EFA98EA0BDB3205885D7E4E4FA7012F71279988ACF0BEAA00000000001976A914F4A101541F3D0EED6FCE73222B43F753293AF88D88AC000000000100000001EE71E366ED915A67A719AAA9DA37720787BF316D3217F2D3ADB53BDBD48DA8DC000000008B48304502205EDD8F2D6BA0CA382292AEA002642F79C419CC67BED0CBEF5BE75A18A2F4007E0221009A2A46010D055AB9F2BEFA07CB3394D26C137BF21ACF9699DCA5AC5568A43ED101410486606D11F1A21C23B881330997C6E58B55BDFA9A758A288611FA893A2ED5D4ABD8DDE9315902F266C27ABCB7F5D58E97F2FBF20BF7EDE386986CC0DADC01F65EFFFFFFFF0229E94515000000001976A914E237DF7DBC7DBB678BBFB288970A709C84201D1888AC404B4C00000000001976A9143F6B5FDB5A732B2135F92CDC97D555D25121470F88AC00000000010000000168A59C95A89ED5E9AF00E90A7823156B02B7811000C63170BB2440D8DB6A1869000000008A473044022050C32CF6CD888178268701A636B189DC3F026EE3EBD230FD77018E54044AAC77022055AA7FA73C524DD4F0BE02694683A21EB03D5D2F2C519D7DC7110B742C417517014104AA5C77986A87B93B03D949013E629601B6DBDBD5FC09F3BEF9263B64B3C38D79D443FAFA2FBF422A203FE433ADF6E071F3172A53747739CE72C640FE7E514981FFFFFFFF0140420F00000000001976A91449CF380ABDB86449EFC694988BF0F447739F73CD88AC000000000100000002B4FFF9CED73624ADBCA5A2C5A65C2EA8678EAB284F926D260589E79DBF7E509F000000008C493046022100DF04A78B0A33E73F08EFA0B3EDBDE245082B03C1D330272E9CC517B4446EF2E3022100DDB406A56C8B7096EA017D30558DF3C8AC755D882DA9C228DC50034CA73A29F1014104F7603B457A46FF87FF8BF309D5224CE0F546BF1549660D988D6AB66C106A92BBEA23CD9D6459AAEABFC0FE1D3B449FE88847E1A10BA8E48911934E306511116FFFFFFFFF25AAA9794B4C4A24CAB09155C392856D07C1106A3B45DFF5E013CC2C5416F083000000008C49304602210093CB5E02E767548445DA3A09BE15FC35226BEF3A5CBDC9B47759DA54A3A57790022100C62106C88EA69197FB6BC5934DFD711BAC847CC6F320AA2218B7A0C36EB0505601410478E9765D9E3F5CA6A3DFF70330E37D27530EA64A01634B3B4764C2315064015C2F8819FE5EEA04A7EA396149C587DDFAC82400246BC54806ADDA37DEFD44DAEEFFFFFFFF0296650F00000000001976A914042F4DDA86079350C9314221542D6ED1FABFC32888AC40420F00000000001976A914019BA13B03758A23E0FE2BFF424534ED44B5AD7588AC00000000");
    
    //ProverSync *ps = new ProverSync;
    //Prover(rawblock, 1);
    
    Block block1 = Block::submitNewBlock(rawblock, 1);
    
    std::cout << "block1.transactions.size(): " << block1.transactions.size() << std::endl;
    

    std::cout << "sequence: " << (uint32_t)block1.transactions[2].outputs[1].scriptPubkey[23] << std::endl;
    
    std::string s;
    std::cin >> s;
    
return 0;
}

